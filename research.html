<meta charset="utf-8">
<link rel="apple-touch-icon" href="research-96.png">
<html>
<head>
<title>Accessible Paintings</title>
<script src="JS/howler.min.js"></script>
<script src="pictureMapData.js"></script>
<style>
@import "research.css";
</style>
<script>
// I am so jquery
function $(n){
return document.getElementById(n);
}

function gup( name )
{
    name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
    var regexS = "[\\?&]"+name+"=([^&#]*)";
    var regex = new RegExp( regexS );
    var results = regex.exec( window.location.href );
    if( results == null )
     {
    return "";
     }
    else
    {
    return results[1];
    };
}


//
var thisPic;

var areas = [];
var soundMap ={};
var descriptionMap = {};

var thisSound = null; // there's only one howler sound playing at once , as a background. descriptions too, really.
var thisDescription= null;

// so it doesn't stop playing when vol == 0 
const QUIET = 0.0; // well, I think this is OK now to be 0.0
const FADE_IN  = 500.0;
const FADE_OUT = 1500.00

function keyToUI(key)
	{
	t = thisPic[key];
	if(t != undefined)
		{
		$('p_'+key).innerHTML = t;
		}
	else
		{
		$('p_'+key).innerHTML="";
		}
	}

function afterLoad()
{
//	$("debug").innerText = "INSTALLING";
	setupFullscreenCallback();
	
	var picture = "Painting1";
	var optional = gup("p");
	if(optional)
	{
		picture = optional;
	}
	
	loadPicture(picture); 
	
	installClicksAndTouches();
}

//iOS likes touches, not mouses. 
// Similarly, listen for touchstart and touchend events on the canvas, but listen for touchcancel events on the HTML body
function installClicksAndTouches()
{
	let can = $('pCanvas');
	
            can.addEventListener("mousedown", mouseDownCanvas, false);
           // can.addEventListener("mousemove", mouseXY, false);
            can.addEventListener("mouseup", mouseUpCanvas, false);

             // iOS touches, boo
          //  can.addEventListener("click", mouseDownCanvas, false);
            can.addEventListener("dblclick",doubleClickedCanvas,false);
 // they want this on the doc body .. I could do that .. 
          //  document.body.addEventListener("mouseup", mouseUpCanvas, false);
            
            // Hmmfigure out these touches!
           // can.addEventListener("touchstart", touchDown, false);
           // can.addEventListener("touchmove", touchXY, true);
           // can.addEventListener("touchend", touchUp, false);
          //  document.body.addEventListener("touchcancel", touchUp, false);
            
}

// figure these out
// try this!
function debugEvent(evt,label)
{
	var mainEvent = evt ? evt : window.event;
	var zox = mainEvent.offsetX/pcW;
	var zoy = mainEvent.offsetY/pcH;
	$("debug").innerText = label+" ("+f3(zox)+", "+f3(zoy)+")"+evt;
}

function debugTouchEvent(evt,label)
{
            if (!e)
                var e = event;
            e.preventDefault();
            canX = (e.targetTouches[0].pageX - can.offsetLeft)/pcW;
            canY = (e.targetTouches[0].pageY - can.offsetTop)/pcH;
	$("debug").innerText = label+" ("+f3(canx)+", "+f3(cany)+")"+evt;
}

function mouseXY(event)
{
	//	debugEvent(event,"mouseXY");

}
function touchXY(e) {
            if (!e)
                var e = event;
            e.preventDefault();
            canX = e.targetTouches[0].pageX - can.offsetLeft;
            canY = e.targetTouches[0].pageY - can.offsetTop;
            	$("debug").innerText = "TOUCH XY:"+" ("+f3(canX)+", "+f3(canY)+")"+e;

}

function touchDown(event)
{
//	debugTouchEvent(event,"touch down");
	mouseDownCanvas(event);
}
function touchUp(event)
{
//	debugTouchEvent(event,"touch up");
	mouseUpCanvas(event);
}


/// updates if we go into FullScreen
var pcW, pcH;

function loadPicture(picKey)
	{
	 thisPic = pictureMap[picKey];
	
	 keyToUI('title');
	 keyToUI('artist');
	 keyToUI('date');
	 keyToUI('medium');
	 keyToUI('dimensions');
	 keyToUI('collection');
	 keyToUI('notes');
	
	//put main image into canvas.
	var pcanvas = $("pCanvas");
	pcW= pcanvas.width = thisPic["size"][0];
	pcH= pcanvas.height = thisPic["size"][1];
	
	var context = pcanvas.getContext("2d");
	var destX = 0;
	var destY = 0;
	var imageObj = new Image();
	imageObj.onload = function() 
		{
			
			// debug: dont
	 context.drawImage(imageObj, destX, destY);
		
		processSVGFrom(thisPic["svgFile"]);
		processSoundMap(thisPic["soundMap"]);
		processDescriptionMap(thisPic["descriptionMap"])

		};
		// sync load of image file this may have to happen again from time to time.
	imageObj.src = thisPic["imageFile"];
		}
		
// By using SVG files, a lot of work is already done.
//
function parseSVGFile()
	{
	if(this.status == 200 &&
	this.responseXML != null  ) 
		{
		// success!
		let svgDoc = this.responseXML;
		// might be fun to parse this up into shapes
		areas=[];
		// i can actually get the svg's idea of dimensions from the svg 
		var vbox= svgDoc.getElementsByTagName("svg")[0].getAttribute("viewBox").split(' ');
		let svgW = parseInt(vbox[2]);
		let svgH = parseInt(vbox[3]);
		// parse that thing...
		var paths = svgDoc.getElementsByTagName("path");
		for( var pathIx=0; pathIx< paths.length;pathIx++)
		{
		let path = paths[pathIx];
		var idId = path.getAttribute("id");
		var colorId = path.getAttribute("fill");
		// get the "d" code
		// we can correlate the path "id" to a sound, or the path "fill" to a sound.
		var draws = path.getAttribute("d").split(' ');
		var nx,ny;
		var thisPath = [];
		// put ZO'd coordinates in the path arrays
		for(var i =0; i<draws.length;i++)
		{
		// M0 751 L35 751
		let cmd = draws[i];
		var n;
		if((cmd[0] == 'M') || (cmd[0] == 'L'))
		{
			n = parseFloat(cmd.slice(1))
		} 
		else
		{
			n = parseFloat(cmd);	
		}
			
		if(i % 2 == 0)
		{
		nx = n/svgW;
		}
		else
		{
		ny = n/svgH;
		thisPath.push([nx,ny]);
		}
		}
		areas.push({"path":thisPath,"ID":colorId});
		}
		
		// debugDraw();

		} 
		else 
		{
	// something went wrong
	alert("xml was not read");
	}
	
}

function processSVGFrom(svgFile)
{
	 // get that xml
	// let  svgDoc=loadXMLDoc(thisPic["svgFile"])
	var client = new XMLHttpRequest();
	client.onload = parseSVGFile;
	client.open("GET", svgFile);
	client.send();
}
		
	
function debugDraw()
{
	var pcanvas = $("pCanvas")
	
	var ctx = pcanvas.getContext("2d");
	ctx.strokeStyle="#CCCC88";
	ctx.lineWidth= 2.0;
	for(var i = 0;i<areas.length;i++)
	{
		let p = areas[i]["path"];
		ctx.beginPath();
		ctx.moveTo(p[0][0],p[0][1]);
		for(var pt=1;pt<p.length;pt++)
		{
			ctx.lineTo(p[pt][0],p[pt][1]);
		}
		ctx.closePath();
		ctx.stroke(); 
	}
	
}
	
// these are the sounds	
function processSoundMap(sMapDict)
{
				//
	soundMap.length = 0;

	
	for(smID in sMapDict)
	{
	// howl sounds for some reason aren't loading??
		var howler = new Howl({ src: [ sMapDict[smID] ], html5: true, loop: true, volume: QUIET});
		
		// play em all the time, just fiddle with the volume!
		howler.play();
		soundMap[smID] = howler;
	}
}

// these are the one-shot description sounds, so they DON'T play allthe time.
function processDescriptionMap(dMapDict)
{
				//
	descriptionMap.length = 0;

	
	for(smID in dMapDict)
	{
	// howl sounds for some reason aren't loading??
		var howler = new Howl({ src: [ dMapDict[smID] ], html5: true, loop: false});
	//howler.play();
		descriptionMap[smID] = howler;
	//
	}
}

	// the insane thing is a I think a button with a map can do this. 
	
function areasWithPZoPt(zox,zoy)
	{
	 var results = [];
	for(var i=0;i<areas.length;i++)
		{
		let tarea = areas[i]["path"];
		 if(pointInPolygon(tarea,zox,zoy))
		 {
		 	results.push(areas[i]["ID"]);
		 }
		}
	return results;
	}

// operating ingredient

const pointInPolygon = function (polygon, tx,ty) {
    //A point is in a polygon if a line from the point to infinity crosses the polygon an odd number of times
    let odd = false;
    //For each edge (In this case for each point of the polygon and the previous one)
    for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
        //If a line from the point into infinity crosses this edge
        if (((polygon[i][1] > ty) !== (polygon[j][1] > ty)) // One point needs to be above, one below our y coordinate
            // ...and the edge doesn't cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)
            && (tx < ((polygon[j][0] - polygon[i][0]) * (ty - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]))) {
            // Invert odd
            odd = !odd;
        }
        j = i;

    }
    //If the number of crossings was odd, the point is in the polygon
    return odd;
};



// kind of old...
function loadXMLDoc(filename)
{
if (window.XMLHttpRequest)
  {
  xhttp=new XMLHttpRequest();
  }
else // code for IE5 and IE6
  {
  xhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
xhttp.open("GET",filename,false);
xhttp.send();
return xhttp.responseXML;
} 


//--- actions
// there could be a volume slider.
var vol = 0.75;

function f3(v)
{
	return Math.floor(v*1000.0 +0.5)/1000.0;
}


//now uses the single howler reference ... and all the sounds play all the time.
// unlike my version, only one at a time.
function mouseDownCanvas(evt)
{
	var mainEvent = evt ? evt : window.event;
	var zox = mainEvent.offsetX/pcW;
	var zoy = mainEvent.offsetY/pcH;
 	console.log("pt (",mainEvent.offsetX,"/",pcW,",",mainEvent.offsetY,"/",pcH,") (",f3(zox)+", "+f3(zoy)+")");
	let results  = areasWithPZoPt(zox,zoy);
//	for(var i =0;i<results.length;i++)
//	{
//		thisSound = soundMap[results[i]];
//		thisSound.fade(QUIET,vol,FADE_OUT);
//	}
		if(results.length>0)
		{
			// we only care about the first one... for now
			// if there was one already that was different, fade it down and fase this one up.
			// ifyou click it again while it's playing and not silent, bring itback I guess. 
			nextSound = soundMap[results[0]];
			console.log("dn:",nextSound._src," vol:",nextSound.volume());
			if(thisSound != nextSound || thisSound.volume() == QUIET )
			{
				//  pull down this playing sound if it exists and is loud enough
				if(thisSound!= null && thisSound.volume() > QUIET)
				{
					thisSound.fade(vol,QUIET,FADE_OUT);
				}
				thisSound = nextSound;
				// bring it up if it's quiet.
				var cvol = thisSound.volume();
				if(cvol<vol)
				{
					
					if(!thisSound.playing())
					{
						thisSound.play();
					}
					thisSound.seek(0); // resynch the loop.
					thisSound.fade(cvol,vol,FADE_IN);
				}
			}
		}
}

function doubleClickedCanvas(evt)
{
	var mainEvent = evt ? evt : window.event;
	var zox = mainEvent.offsetX/pcW;
	var zoy = mainEvent.offsetY/pcH;
//	$("debug").innerText = "("+f3(zox)+", "+f3(zoy)+")";
	let results  = areasWithPZoPt(zox,zoy);
		if(thisDescription)
		{
			thisDescription.stop();
		}
//	for(var i =0;i<results.length;i++)
//	{
//
//		thisDescription= descriptionMap[results[i]];
//		thisDescription.volume(vol);
//		thisDescription.play();
//	}
		if(results.length>0)
		{
			thisDescription= descriptionMap[results[0]];
			thisDescription.volume(vol);
			thisDescription.play();
		}
	
}

// Only one sound could possibly be playing, so fade it
function mouseUpCanvas(evt)
{
		if(thisSound)
		{
			console.log("up:",thisSound._src," vol:",thisSound.volume());
			var cvol = thisSound.volume();
			thisSound.fade(cvol, QUIET,FADE_OUT);
			// can I kill it here? not really needed.
//			thisSound = null;
		}
}
 
// Full screenery

function setupFullscreenCallback()
{
	// well this doen't work at all.
	$("pCanvas").addEventListener('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', function () {
		// what I want to do is fix the Canvas' height and width, wrt the mouse events.
		// this is OK, but not super helpful here.
          if (fullscreenElement != null) {
              console.info("Went full screen");
          } else {
              console.info("Exited full screen");              
          }
          
          //
          screenChanged();
          
      });
}

 
 function fullScreenToggle()
 {
 	let elem = $("pCanvas");
 	  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { /* Safari */
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { /* IE11 */
    elem.msRequestFullscreen();
  }
 
 }
 // this doesn't happen
 function screenChanged()
 {
 	// this is to convert the mouse positions.

 	console.log("screenchanged:", $('body').width());
 	let canv = $('pCanvas');
 	pcW = canv.width;
 	pcH = canv.height;
 }
 
</script>

</head>
<body onLoad="javascript:afterLoad();">
<span id="debug"></span><br/>
<!--
<canvas id="pCanvas" onmousedown="mouseDownCanvas(event)"
					ondblclick="doubleClickedCanvas(event)"
					onmouseup="mouseUpCanvas(event)"
					 onfullscreenchange="screenChanged(event);"></canvas>-->
	<canvas id="pCanvas" 
					 onfullscreenchange="screenChanged(event);"></canvas>				 
<br />
<br />
<div class="box r" style="text-align: center; font-size:2em;" onClick="javascript:fullScreenToggle();"> Full screen (ESC to escape) </div>
</canvas>
<br />
<div class="box r">
<table>
<tr><th>Title:</th><td id="p_title"></td></tr>
<tr><th>Artist:</th><td id="p_artist"></td></tr>
<tr><th>Date:</th><td id="p_date"></td></tr>
<tr><th>Medium:</th><td id="p_medium"></td></tr>
<tr><th>Dimensions:</th><td id="p_dimensions"></td></tr>
<tr><th>Collection:</th><td id="p_collection"></td></tr>
<tr><th>Notes:</th><td id="p_notes"></td></tr>
</table>
</div>
<div class="box r"> Paintings:<br />
<a href="research.html?p=Painting1"> Painting 1</a> <br />
<a href="research.html?p=Painting2"> Painting 2</a> <br />
</div>
</body>
</html>
