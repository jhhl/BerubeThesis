<meta charset="utf-8">
<link rel="apple-touch-icon" href="research-96.png">
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16" />
<html>
<head>
<title>Accessible Paintings</title>
<script src="JS/howler.min.js"></script>
<script src="pictureMapData.js"></script>
<style>
@import "research.css";
</style>
<script>
// I am so jquery
function $(n){
return document.getElementById(n);
}

function gup( name )
{
    name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
    var regexS = "[\\?&]"+name+"=([^&#]*)";
    var regex = new RegExp( regexS );
    var results = regex.exec( window.location.href );
    if( results == null )
     {
    return "";
     }
    else
    {
    return results[1];
    };
}


//
var thisPic;

var areas = [];
var soundMap ={};
var descriptionMap = {};
var thisSoundId = '#000000';
var nextSoundId = '#000000';
var isDown = false;

var thisSound = null; // there's only one howler sound playing at once , as a background. descriptions too, really.
var thisDescription= null;

// so it doesn't stop playing when vol == 0 
const QUIET = 0.001; // well, I think this is OK now to be 0.0
const LOUD = 0.75;
const FADE_IN  = 500.0;
const FADE_OUT = 1500.00
var global_vol = LOUD; // may be adjusted with a slider

// debug stuff
 var scnX, scnY;
 var isTouch=false;
 
 
function keyToUI(key)
	{
	t = thisPic[key];
	if(t != undefined)
		{
		$('p_'+key).innerHTML = t;
		}
	else
		{
		$('p_'+key).innerHTML="";
		}
	}

function afterLoad()
{
//	$("debug").innerText = "INSTALLING";
	setupFullscreenCallback();
	
	var picture = "Painting1";
	var optional = gup("p");
	if(optional)
	{
		picture = optional;
	}
	
	setupPicture(picture); 
	installClicksAndTouches();
}



/// updates if we go into FullScreen
var pcW, pcH;

function setupPicture(picKey)
	{
	 thisPic = pictureMap[picKey];
	
	 keyToUI('title');
	 keyToUI('artist');
	 keyToUI('date');
	 keyToUI('medium');
	 keyToUI('dimensions');
	 keyToUI('collection');
	 keyToUI('notes');
	
	//put main image into canvas.
	var pcanvas = $("pCanvas");
	pcW= pcanvas.width = thisPic["size"][0];
	pcH= pcanvas.height = thisPic["size"][1];
	
	var context = pcanvas.getContext("2d");
	var destX = 0;
	var destY = 0;
	var imageObj = new Image();
	imageObj.onload = function() 
		{
			
			// debug: dont
	 context.drawImage(imageObj, destX, destY);
		
		processSVGFrom(thisPic["svgFile"]);
		processSoundMap(thisPic["soundMap"]);
		processDescriptionMap(thisPic["descriptionMap"])

		};
		// sync load of image file this may have to happen again from time to time.
	imageObj.src = thisPic["imageFile"];
		}
		
// By using SVG files, a lot of work is already done.
//
function parseSVGFile()
	{
	if(this.status == 200 &&
	this.responseXML != null  ) 
		{
		// success!
		let svgDoc = this.responseXML;
		// might be fun to parse this up into shapes
		areas=[];
		// i can actually get the svg's idea of dimensions from the svg 
		var vbox= svgDoc.getElementsByTagName("svg")[0].getAttribute("viewBox").split(' ');
		let svgW = parseInt(vbox[2]);
		let svgH = parseInt(vbox[3]);
		// parse that thing...
		var paths = svgDoc.getElementsByTagName("path");
		for( var pathIx=0; pathIx< paths.length;pathIx++)
		{
		let path = paths[pathIx];
		var idId = path.getAttribute("id");
		var colorId = path.getAttribute("fill");
		// get the "d" code
		// we can correlate the path "id" to a sound, or the path "fill" to a sound.
		var draws = path.getAttribute("d").split(' ');
		var nx,ny;
		var thisPath = [];
		// put ZO'd coordinates in the path arrays
		for(var i =0; i<draws.length;i++)
		{
		// M0 751 L35 751
		let cmd = draws[i];
		var n;
		if((cmd[0] == 'M') || (cmd[0] == 'L'))
		{
			n = parseFloat(cmd.slice(1))
		} 
		else
		{
			n = parseFloat(cmd);	
		}
			
		if(i % 2 == 0)
		{
		nx = n/svgW;
		}
		else
		{
		ny = n/svgH;
		thisPath.push([nx,ny]);
		}
		}
		areas.push({"path":thisPath,"ID":colorId});
		}
		
		// debugDraw();

		} 
		else 
		{
	// something went wrong
	alert("xml was not read");
	}
	
}

function processSVGFrom(svgFile)
{
	 // get that xml
	// let  svgDoc=loadXMLDoc(thisPic["svgFile"])
	var client = new XMLHttpRequest();
	client.onload = parseSVGFile;
	client.open("GET", svgFile);
	client.send();
}
		
	
function debugDraw()
{
	var pcanvas = $("pCanvas")
	
	var ctx = pcanvas.getContext("2d");
	ctx.strokeStyle="#CCCC88";
	ctx.lineWidth= 2.0;
	for(var i = 0;i<areas.length;i++)
	{
		let p = areas[i]["path"];
		ctx.beginPath();
		ctx.moveTo(p[0][0],p[0][1]);
		for(var pt=1;pt<p.length;pt++)
		{
			ctx.lineTo(p[pt][0],p[pt][1]);
		}
		ctx.closePath();
		ctx.stroke(); 
	}
	
}
	
// these are the sounds	

function processSoundMap(sMapDict)
{
//
	soundMap = {};
// add silence which should actually be in in the config file. 
// always loud even though it's silen so it never goes away. heh. doesn't matter if it's mute or not. 
	var silent = new Howl({ src: ['sounds/Shapes/0_silence.mp3'], html5: true, loop: true, volume: LOUD,mute:true});
	soundMap['#000000'] = silent;
	
	for(smID in sMapDict)
	{
	// howl sounds for some reason if loaded with vol QUIET aren't quiet at all.
	// mute though is problematic.
		var howler = new Howl({ src: [ sMapDict[smID] ], html5: true, loop: true, volume: QUIET,mute:true});
 
			soundMap[smID] = howler;
			// play em all the time, just fiddle with the volume!
			soundMap[smID].play();
			soundMap[smID].volume(QUIET); // maybe it'll believe it this time.
			soundMap[smID].mute(false);
	}
}
 

// these are the one-shot description sounds, so they DON'T play allthe time.
function processDescriptionMap(dMapDict)
{
				//
	descriptionMap.length = 0;

	
	for(smID in dMapDict)
	{
	// howl sounds for some reason aren't loading??
		var howler = new Howl({ src: [ dMapDict[smID] ], html5: true, loop: false});
		//howler.play(); // this is only or debugging....
		descriptionMap[smID] = howler;
	//
	}
}

	// the insane thing is a I think a button with a map can do this. 
	
function areasWithPZoPt(zox,zoy)
	{
	 var results = [];
	for(var i=0;i<areas.length;i++)
		{
		let tarea = areas[i]["path"];
		 if(pointInPolygon(tarea,zox,zoy))
		 {
		 	results.push(areas[i]["ID"]);
		 }
		}
	return results;
	}

// operating ingredient

const pointInPolygon = function (polygon, tx,ty) {
    //A point is in a polygon if a line from the point to infinity crosses the polygon an odd number of times
    let odd = false;
    //For each edge (In this case for each point of the polygon and the previous one)
    for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
        //If a line from the point into infinity crosses this edge
        if (((polygon[i][1] > ty) !== (polygon[j][1] > ty)) // One point needs to be above, one below our y coordinate
            // ...and the edge doesn't cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)
            && (tx < ((polygon[j][0] - polygon[i][0]) * (ty - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]))) {
            // Invert odd
            odd = !odd;
        }
        j = i;

    }
    //If the number of crossings was odd, the point is in the polygon
    return odd;
};



// kind of old...
function loadXMLDoc(filename)
{
if (window.XMLHttpRequest)
  {
  xhttp=new XMLHttpRequest();
  }
else // code for IE5 and IE6
  {
  xhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
xhttp.open("GET",filename,false);
xhttp.send();
return xhttp.responseXML;
} 


//--- actions
// debug function
function f3(v)
{
	return Math.floor(v*1000.0 +0.5)/1000.0;
}

// raw x,y from the screen is converted to zo versions and then looked up
// this actually lets you return overlapping areas, buuuut, we will only use the first for now. 
//pcH and pcW in theory scale with full screening, buuut .. it's not super accurate. 
//
function soundIdsForXY(screenX,screenY)
{
	var zox = screenX/pcW;
	var zoy = screenY/pcH;
	// a little debug here for fullscreen
 //	console.log("pt (",screenX,"/",pcW,",",screenY,"/",pcH,") (",f3(zox)+", "+f3(zoy)+")");
	return areasWithPZoPt(zox,zoy);
}

// soundId is actually a color!
// all sounds should be playing all the time, even if vol == 0 .0
function playBgSound(newSoundId)
{

	// still paying this one? make it louder
	 if(newSoundId == thisSoundId)
	 {
	 	//we may want to pump up the volume
	 	let cvol = soundMap[thisSoundId].volume();
	 	if(cvol<global_vol)
	 	{
	 		console.log("play pump:",newSoundId,cvol);
	 		//soundMap[thisSoundId].play(); //in case it got eaten
	 		soundMap[thisSoundId].volume(global_vol);
	 		//soundMap[thisSoundId].fade(cvol, global_vol,FADE_IN);
	 	}
	 }
	 else
	 {
	 	console.log("play new:",newSoundId);
	 	// new sound to get faded in
	 	// fade down the currrent one if it's heard at all
	 	// well, fade down eveyone!
	 	for (let sid in soundMap)
	 	{	 		
	 		let theSound  = soundMap[sid];
	 		if(sid != newSoundId)
			{
				// fade is not working too well
				if(isTouch)
				{
					theSound.volume(QUIET);
					// OH SHUTUP
					theSound.mute(true);
				}
				else
				{
					let cvol = theSound.volume();
					if(cvol>QUIET)
					{					
						theSound.fade(cvol, QUIET,FADE_OUT);
					}
				}
			}
	 	}
	 	
		// I'm assuming the new sound is quiet .. but maybe it isn't
		//make sure it's playing because sometimes it's not of vol == 0 
		// might have to wait for it to be playing
		// trouble with a redundant play is that it seeks, causing a hiccup.
		// other trouble is taht it thinks it IS playing but in fact it isn't. 
//		if(soundMap[newSoundId].playing())
//		{
//				//soundMap[newSoundId].volume(global_vol);
//				let nvol = soundMap[newSoundId].volume();
//				soundMap[newSoundId].fade(nvol, global_vol,FADE_IN);
//		}
//		else
//		{
			let mySound = soundMap[newSoundId];
			mySound.once('play', 
				function(){
				// fade not working too well 
				// I bet "this" will work here
				this.mute(false);

				if(isTouch)
				{
					this.volume(global_vol);
				}
				else
				{
					let nvol = mySound.volume();
					this.fade(nvol, global_vol,FADE_IN);
				}
				}
			);
			mySound.play();
//		}

		
		// swap it
		thisSoundId = newSoundId;
	 }
}


// this is for moving and touchdown.
// touchup is equivalent to moving to area #000000
// it's possible touchdown ALSO does a seek(0)
function playBgSoundForScreenXY(screenX,screenY)
{
	if(isDown)
	{
		let soundIds = soundIdsForXY(screenX,screenY);
		if(soundIds.length>0)
		{
			let newSoundId = soundIds[0];
			if(isTouch)
				{ 
					$("debug").innerText = "TOUCH XY:"+" ("+f3(canX)+", "+f3(canY)+") "+ newSoundId;
				};
			playBgSound(newSoundId);
		}
	}
}

// moves department

//iOS likes touches, not mouses. 
// Similarly, listen for touchstart and touchend events on the canvas, but listen for touchcancel events on the HTML body
function installClicksAndTouches()
{
	let can = $('pCanvas');
	can.addEventListener("mousedown", mouseDownCanvas, false);
	can.addEventListener("mousemove", mouseMoveCanvas, false);
	can.addEventListener("mouseup", mouseUpCanvas, false);
	
	can.addEventListener("dblclick",doubleClickedCanvas,false);
	// they want this on the doc body .. I could do that .. but maybe not.
	document.body.addEventListener("mouseup", mouseUpCanvas, false);
	
	// Hmm figure out these touches!
	can.addEventListener("touchstart", touchDown, false);
	can.addEventListener("touchmove", touchMove, true);
	can.addEventListener("touchend", touchUp, false);
	document.body.addEventListener("touchcancel", touchUp, false);
}

//  

// figure these out
// try this!
function debugEvent(evt,label)
{
	var mainEvent = evt ? evt : window.event;
	var zox = mainEvent.offsetX/pcW;
	var zoy = mainEvent.offsetY/pcH;
	$("debug").innerText = label+" ("+f3(zox)+", "+f3(zoy)+")"+evt;
}

function debugTouchEvent(evt,label)
{
	if (!e)
		var e = event;
	canX = (e.targetTouches[0].pageX - can.offsetLeft)/pcW;
	canY = (e.targetTouches[0].pageY - can.offsetTop)/pcH;
	$("debug").innerText = label+" ("+f3(canx)+", "+f3(cany)+")"+evt;
}

 // touch support
function touchMove(touchE) {
	isTouch=true;
	if (!touchE)
		var touchE = event; // where is this from?
		// for some reason, this is empty sometimes
	let ttouches = touchE.targetTouches;
	if (ttouches.length>0)
	{
		let firstTouch = ttouches[0];
		// moves on the canvas are ignored for control purposes. 
		// this , unfortunately, resules in no doubleclick???
		touchE.preventDefault();
		// this logic is for touches, ?? 
	 	let canv = $('pCanvas');
		canX = firstTouch.pageX - canv.offsetLeft;
		canY = firstTouch.pageY - canv.offsetTop;
		
		scnX=canX; // for debug
		scnY=canY;
		
		 playBgSoundForScreenXY(canX,canY);
	}
}

function touchDown(event)
{
	isTouch=true;
		console.log("touch down");
// might be dangerous to turn on...
//	e.preventDefault(); // turns off some scrolling features on tablets
	isDown=true;
 	touchMove(event);
}
function touchUp(event)
{
		isTouch=true;
	console.log("touch up");
//	e.preventDefault(); // turns off some scrolling features on tablets
	playBgSound("#000000");
	isDown=false;
}

//now uses the single howler reference ... and all the sounds play all the time.
// unlike my version, only one at a time.
function mouseDownCanvas(evt)
{
	isTouch=false;
	console.log("down");
	isDown=true;
	var mainEvent = evt ? evt : window.event;
	playBgSoundForScreenXY(mainEvent.offsetX,mainEvent.offsetY)
}
function mouseMoveCanvas(evt)
{
	isTouch=false;
	var mainEvent = evt ? evt : window.event;
	playBgSoundForScreenXY(mainEvent.offsetX,mainEvent.offsetY)
}

// doubl click just fire off one shots, so, not sophisticated. 
// also: works on tablets. 
function doubleClickedCanvas(evt)
{
	var mainEvent = evt ? evt : window.event;
	var zox = mainEvent.offsetX/pcW;
	var zoy = mainEvent.offsetY/pcH;
//	$("debug").innerText = "("+f3(zox)+", "+f3(zoy)+")";
	let results  = areasWithPZoPt(zox,zoy);
		if(thisDescription)
		{
			// shut it up if it's still playing
			thisDescription.stop();
		}
		if(results.length>0)
		{
			thisDescription= descriptionMap[results[0]];
			thisDescription.volume(global_vol);
			thisDescription.play();
		}
}

// Only one sound could possibly be playing, so fade it out
function mouseUpCanvas(evt)
{
	isTouch=false;
	console.log("up");
	let dSound = soundMap[thisSoundId];
	console.log("up:",thisSoundId,dSound._src," vol:",dSound.volume());
	playBgSound('#000000');
	isDown=false;
	
}
 
 
 
 
 
 
 
// Full screenery
// this doesn't work, bleh
function setupFullscreenCallback()
{
	// well this doen't work at all.
	$("pCanvas").addEventListener('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', function () {
		// what I want to do is fix the Canvas' height and width, wrt the mouse events.
		// this is OK, but not super helpful here.
          if (fullscreenElement != null) {
              console.info("Went full screen");
          } else {
              console.info("Exited full screen");              
          }
          
          //
          screenChanged();
          
      });
}

 
 function fullScreenToggle()
 {
 	let elem = $("pCanvas");
 	  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { /* Safari */
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { /* IE11 */
    elem.msRequestFullscreen();
  }
 
 }
 // this doesn't happen
 function screenChanged()
 {
 	// this is to convert the mouse positions.

 	console.log("screenchanged:", $('body').width());
 	let canv = $('pCanvas');
 	pcW = canv.width;
 	pcH = canv.height;
 }
 
</script>

</head>
<body onLoad="javascript:afterLoad();">
<span id="debug"></span><br/>
<canvas id="pCanvas" onfullscreenchange="screenChanged(event);"></canvas>				 
<br />
<br />
<div class="box r" style="text-align: center; font-size:2em;" onClick="javascript:fullScreenToggle();"> Full screen (ESC to escape) </div>
</canvas>
<br />
<div class="box r">
<table>
<tr><th>Title:</th><td id="p_title"></td></tr>
<tr><th>Artist:</th><td id="p_artist"></td></tr>
<tr><th>Date:</th><td id="p_date"></td></tr>
<tr><th>Medium:</th><td id="p_medium"></td></tr>
<tr><th>Dimensions:</th><td id="p_dimensions"></td></tr>
<tr><th>Collection:</th><td id="p_collection"></td></tr>
<tr><th>Notes:</th><td id="p_notes"></td></tr>
</table>
</div>
<div class="box r"> Paintings:<br />
<a href="research.html?p=Painting1"> Painting 1</a> <br />
<a href="research.html?p=Painting2"> Painting 2</a> <br />
</div>
</body>
</html>
